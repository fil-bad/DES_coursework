#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{matlab-prettifier}
\usepackage{geometry}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "style={Matlab-editor}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Coursework DES
\end_layout

\begin_layout Author
Filippo Badalamenti (CID: 01998569)
\end_layout

\begin_layout Standard
The system that will be analysed is composed by a robot that can move in
 a specific environment (possible case of path planning, where control aspects
 are delegated to every single state in an hypotetic hybrid system).
 While the entire work done willl be presented along this coursework, all
 the Matlab code and file used will be also provided through the following
 link: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/fil-bad/DES_coursework
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Modeling the map 
\end_layout

\begin_layout Standard
Since map and transition rules between rooms are provided, we can rapidly
 derive our finite deterministic automaton (FDA)
\begin_inset Foot
status open

\begin_layout Plain Layout
We are going to use this tool 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.cs.unc.edu/~otternes/comp455/fsm_designer/
\end_layout

\end_inset

 to rapidly generate an SVG file of the automaton; however, due to its intrinsic
 limitations, the initial state will be represented by a single arrow that
 doesn't start from any state.
 
\end_layout

\end_inset

 
\begin_inset Formula $G_{M}$
\end_inset

, where 
\begin_inset Formula $E=\left\{ n,s,e,w\right\} $
\end_inset

 and 
\begin_inset Formula $X=\left\{ Rm1,Rm2,Rm3,Rm4,Rm5,Rm6,Rm7\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 30text%
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Discrete Event Systems/DES_coursework/imgs/Map_automaton.svg
	width 40text%

\end_inset


\begin_inset space \hspace{}
\length 30text%
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Formula $G_{M}$
\end_inset

 automaton.
\end_layout

\end_inset


\end_layout

\end_inset

Notice that in the following discussion the terminal state is not required
 since, as we can see from the next points, we will try to locate ourselves
 from an unknown starting state.
 
\end_layout

\begin_layout Section
Modeling the robot
\end_layout

\begin_layout Standard
Is this case the automaton 
\begin_inset Formula $G_{R}$
\end_inset

is described by 
\begin_inset Formula $E=\left\{ r,n,s,e,w\right\} $
\end_inset

, and 
\begin_inset Formula $X=\left\{ N,S,E,W\right\} $
\end_inset

, where each state tells towards where the robot is facing.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 30text%
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Discrete Event Systems/DES_coursework/imgs/Robot_automaton.svg
	width 40text%

\end_inset


\begin_inset space \hspace{}
\length 30text%
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Formula $G_{R}$
\end_inset

 automaton.
\end_layout

\end_inset


\end_layout

\end_inset

As we can see, both requests are satisfied – keeping track of robot heading,
 ensuring that only the movement in the front-facing direction is enabled
 –.
 Since the choice of the initial state does not matter, we choose 
\begin_inset Formula $N$
\end_inset

 as initial one.
\end_layout

\begin_layout Section
Modeling the robot inside the map 
\end_layout

\begin_layout Standard
We can define the automata 
\begin_inset Formula $G_{M}$
\end_inset

 and 
\begin_inset Formula $G_{R}$
\end_inset

 in Matlab through the following structures:
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Matlab,numbers=left,stepnumber=5,tabsize=4"
inline false
status open

\begin_layout Plain Layout

% Map Automaton
\end_layout

\begin_layout Plain Layout

G_M = struct("E",0, "X",0, "f",0, "x0",0);
\end_layout

\begin_layout Plain Layout

G_M.E = ['n','s','e','w']';
\end_layout

\begin_layout Plain Layout

G_M.X = ["Rm1","Rm2","Rm3","Rm4","Rm5","Rm6","Rm7"]';
\end_layout

\begin_layout Plain Layout

G_M.f = [
\end_layout

\begin_layout Plain Layout

		1,2,3;
\end_layout

\begin_layout Plain Layout

		2,1,4;
\end_layout

\begin_layout Plain Layout

		2,3,2;
\end_layout

\begin_layout Plain Layout

		3,2,1;
\end_layout

\begin_layout Plain Layout

		3,7,3;
\end_layout

\begin_layout Plain Layout

		7,3,4;
\end_layout

\begin_layout Plain Layout

		3,4,2;
\end_layout

\begin_layout Plain Layout

		4,3,1;
\end_layout

\begin_layout Plain Layout

		4,5,2;
\end_layout

\begin_layout Plain Layout

		5,4,1;
\end_layout

\begin_layout Plain Layout

		5,6,4;
\end_layout

\begin_layout Plain Layout

		6,5,3
\end_layout

\begin_layout Plain Layout

		];
\end_layout

\begin_layout Plain Layout

G_M.x0 = "Rm1";
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Matlab,numbers=left,stepnumber=5,tabsize=4"
inline false
status open

\begin_layout Plain Layout

% Robot Automaton
\end_layout

\begin_layout Plain Layout

G_R = struct("E",0, "X",0, "f",0, "x0",0);
\end_layout

\begin_layout Plain Layout

G_R.E = ['n','s','e','w','r']';
\end_layout

\begin_layout Plain Layout

G_R.X = ["N","S","E","W"]';
\end_layout

\begin_layout Plain Layout

G_R.f = [
\end_layout

\begin_layout Plain Layout

		1,1,1;
\end_layout

\begin_layout Plain Layout

		1,3,5;
\end_layout

\begin_layout Plain Layout

		2,2,2;
\end_layout

\begin_layout Plain Layout

		2,4,5;
\end_layout

\begin_layout Plain Layout

		3,3,3;
\end_layout

\begin_layout Plain Layout

		3,2,5;
\end_layout

\begin_layout Plain Layout

		4,4,4;
\end_layout

\begin_layout Plain Layout

		4,1,5
\end_layout

\begin_layout Plain Layout

		];
\end_layout

\begin_layout Plain Layout

G_R.x0 = "N";
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Remembering the definition of parallel composition, it ends up that in our
 case:
\begin_inset Formula 
\[
G_{Tot}=G_{M}\Vert G_{R}=\left\{ E_{M}\cup E_{R},X_{M}\times X_{R},f,\left(X_{0,M},X_{0,R}\right)\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
and then we have to implement the new transition matrix, following the rules
 seen during class, that are:
\begin_inset Formula 
\[
f\left(\left(x_{M},x_{R}\right),e\right)\coloneqq\begin{cases}
\left(f_{1}\left(x_{M},e\right),x_{R}\right) & ,\;e\in E_{1}\setminus E_{2}\wedge f_{1}\left(x_{M},e\right)\:defined\\
\left(x_{M},f_{2}\left(x_{R},e\right)\right) & ,\;e\in E_{2}\setminus E_{1}\wedge f_{2}\left(x_{R},e\right)\:defined\\
\left(f_{1}\left(x_{M},e\right),f_{2}\left(x_{R},e\right)\right) & ,\;e\in E_{1}\cap E_{2}\wedge f_{1,2}\left(x_{M,R},e\right)\:defined\\
undefined & ,\;otherwise
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Now, we can define a Matlab function to obtain the parallel automaton.
 Due to the length of the code involved, it will be first conceptually analysed
 through bullet points, and then presented as the whole code:
\end_layout

\begin_layout Enumerate
The 
\emph on
union
\emph default
 of the two event set is carried out; to achieve this, the entire 
\begin_inset Formula $E_{1}$
\end_inset

 set is taken and then every other event in 
\begin_inset Formula $E_{2}$
\end_inset

 not already included is added.
\end_layout

\begin_layout Enumerate
The
\emph on
 cartesian product
\emph default
 of the two set of states is done generating each possible combination and
 rearranging it in a column vector.
 Although not fully efficient, the proposed method is conceptually easier.
\end_layout

\begin_layout Enumerate
For the 
\emph on
transition matrix
\emph default
, we have to implement the previously presented possible cases, looking
 for each combination of states:
\end_layout

\begin_deeper
\begin_layout Enumerate
if we have a private event (for 
\begin_inset Formula $E_{1}$
\end_inset

 or 
\begin_inset Formula $E_{2}$
\end_inset

), then we check if it were an active event for that state, and if so, the
 opportune transition is computed and added to the list (taking in account
 that the update has to follow the new arrangement of the states).
 
\end_layout

\begin_layout Enumerate
if we have a shared event (that is 
\begin_inset Formula $E_{1}\cap E_{2}$
\end_inset

), the transition in each automaton must be defined, so that the resulting
 one is given by their combination.
 In this case the triplet of 
\begin_inset Formula $\begin{bmatrix}x & f\left(x,e\right) & e\end{bmatrix}$
\end_inset

 is given by the rule:
\size footnotesize

\begin_inset Formula 
\[
\begin{bmatrix}x1+(x2-1)*length(G\_in1.X) & G\_in1.f(t1,2)+(G\_in2.f(t2,2)-1)*length(G\_in1.X) & e\end{bmatrix}
\]

\end_inset


\size default

\begin_inset Newline newline
\end_inset

Notice that the offset 
\begin_inset Formula $(x2-1)*length(G\_in1.X)$
\end_inset

 is required in order to convert a matrix notation into a vector.
\end_layout

\begin_layout Enumerate
In any other case, the step of the loop is skipped.
\end_layout

\end_deeper
\begin_layout Enumerate
For the 
\emph on
initial state
\emph default
, their sum is considered in the resulting automaton.
\end_layout

\begin_layout Standard
Now we are ready to read through the code, even if it is suggested to download
 it from GitHub and visualize it through a proper text editor: 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newgeometry{left=1.5cm, right=1.5cm, top=1.5cm, bottom=1.5cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\begin_inset listings
lstparams "language=Matlab,numbers=left,stepnumber=10,basicstyle={\scriptsize},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

function G_out = par_comp(G_in1, G_in2) 
\end_layout

\begin_layout Plain Layout

% This function will merge two automata through the parallel operator,
\end_layout

\begin_layout Plain Layout

% outputting the resulting struct.
 Due to the several operation involved,
\end_layout

\begin_layout Plain Layout

% we will separe each section to be computed.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G_out = struct("E",0, "X",0, "f",0, "x0",0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Part I: compute the set of events.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G_out.E = G_in1.E; % initial events set
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\end_layout

\begin_layout Plain Layout

for i = 1:length(G_in2.E)
\end_layout

\begin_layout Plain Layout

    if ~(ismember( G_in2.E(i), G_in1.E ))
\end_layout

\begin_layout Plain Layout

        G_out.E(end+1) =  G_in2.E(i);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

% Part II: compute the new states.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x_tmp = [];
\end_layout

\begin_layout Plain Layout

for i = 1:length(G_in2.X)
\end_layout

\begin_layout Plain Layout

    x_tmp = [x_tmp; G_in1.X + G_in2.X(i)];
\end_layout

\begin_layout Plain Layout

end 
\end_layout

\begin_layout Plain Layout

% the resulting states are now in a column vector of X_1*X_2 length
\end_layout

\begin_layout Plain Layout

G_out.X = x_tmp;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Part III: compute the transition matrix.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f_tmp = [];
\end_layout

\begin_layout Plain Layout

for x1 = 1:length(G_in1.X) % for each new state
\end_layout

\begin_layout Plain Layout

    for x2 = 1:length(G_in2.X)
\end_layout

\begin_layout Plain Layout

        for e = 1:length(G_out.E) % for each new event
\end_layout

\begin_layout Plain Layout

        	if (ismember( G_out.E(e),G_in1.E ) && ...
\end_layout

\begin_layout Plain Layout

				~ismember( G_out.E(e), G_in2.E )) % E1 private event
\end_layout

\begin_layout Plain Layout

                     
\end_layout

\begin_layout Plain Layout

				event = find( G_in1.E == G_out.E(e));
\end_layout

\begin_layout Plain Layout

				for t = 1:length(G_in1.f)
\end_layout

\begin_layout Plain Layout

                    if (all((G_in1.f(t,:) == [x1 0 event]) == [1 0 1]))
\end_layout

\begin_layout Plain Layout

                        % the transition is well defined  
\end_layout

\begin_layout Plain Layout

						f_tmp = [f_tmp;
\end_layout

\begin_layout Plain Layout

								[x1+(x2-1)*length(G_in1.X) G_in1.f(t,2)+(x2-1)*length(G_in1.X) e]
\end_layout

\begin_layout Plain Layout

                                ];
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			elseif (~ismember( G_out.E(e),G_in1.E ) && ...
\end_layout

\begin_layout Plain Layout

                    ismember( G_out.E(e), G_in2.E )) % E2 private event
\end_layout

\begin_layout Plain Layout

						
\end_layout

\begin_layout Plain Layout

				event = find( G_in2.E == G_out.E(e) );
\end_layout

\begin_layout Plain Layout

                for t = 1:length(G_in2.f)
\end_layout

\begin_layout Plain Layout

                    if (all((G_in2.f(t,:) == [x2 0 event]) == [1 0 1]))
\end_layout

\begin_layout Plain Layout

                        % the transition is well defined
\end_layout

\begin_layout Plain Layout

                        f_tmp = [f_tmp;
\end_layout

\begin_layout Plain Layout

								[x1+(x2-1)*length(G_in1.X) x1+(G_in2.f(t,2)-1)*length(G_in1.X) e]
\end_layout

\begin_layout Plain Layout

                                ];
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			elseif (ismember( G_out.E(e),G_in1.E ) && ...
\end_layout

\begin_layout Plain Layout

                    ismember( G_out.E(e), G_in2.E )) % shared event
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				event1 = find( G_in1.E == G_out.E(e) );
\end_layout

\begin_layout Plain Layout

				event2 = find( G_in2.E == G_out.E(e) );
\end_layout

\begin_layout Plain Layout

				for t1 = 1:length(G_in1.f)
\end_layout

\begin_layout Plain Layout

                    if (all((G_in1.f(t1,:) == [x1 0 event1]) == [1 0 1]))
\end_layout

\begin_layout Plain Layout

                        for t2 = 1:length(G_in2.f)
\end_layout

\begin_layout Plain Layout

							if (all((G_in2.f(t2,:) == [x2 0 event2]) == [1 0 1]))
\end_layout

\begin_layout Plain Layout

                                % the transition is well defined for both
 states  
\end_layout

\begin_layout Plain Layout

                                f_tmp = [f_tmp;
\end_layout

\begin_layout Plain Layout

						[x1+(x2-1)*length(G_in1.X) G_in1.f(t1,2)+(G_in2.f(t2,2)-1)*length(G_in1.X)
 e]
\end_layout

\begin_layout Plain Layout

										];
\end_layout

\begin_layout Plain Layout

                            end
\end_layout

\begin_layout Plain Layout

                        end
\end_layout

\begin_layout Plain Layout

                    end
\end_layout

\begin_layout Plain Layout

                end
\end_layout

\begin_layout Plain Layout

			else
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

G_out.f = f_tmp; % finally, assigning the computation to the output automaton
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Part IV: compute the initial condition.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G_out.x0 = G_in1.x0 + G_in2.x0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
restoregeometry
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Finally, as from the assignment request, we can list states, events and
 transition matrix if the automaton 
\begin_inset Formula $G_{M}\parallel G_{R}$
\end_inset

:
\end_layout

\begin_layout Standard

\size scriptsize
\begin_inset Formula 
\[
\begin{array}{ccc}
\mathbf{E}=\left(\begin{array}{c}
n\\
s\\
e\\
w\\
r
\end{array}\right) & \mathbf{X}=\left(\begin{array}{c}
\mathrm{Rm1N}\\
\mathrm{Rm2N}\\
\mathrm{Rm3N}\\
\mathrm{Rm4N}\\
\mathrm{Rm5N}\\
\mathrm{Rm6N}\\
\mathrm{Rm7N}\\
\mathrm{Rm1S}\\
\mathrm{Rm2S}\\
\mathrm{Rm3S}\\
\mathrm{Rm4S}\\
\mathrm{Rm5S}\\
\mathrm{Rm6S}\\
\mathrm{Rm7S}\\
\mathrm{Rm1E}\\
\mathrm{Rm2E}\\
\mathrm{Rm3E}\\
\mathrm{Rm4E}\\
\mathrm{Rm5E}\\
\mathrm{Rm6E}\\
\mathrm{Rm7E}\\
\mathrm{Rm1W}\\
\mathrm{Rm2W}\\
\mathrm{Rm3W}\\
\mathrm{Rm4W}\\
\mathrm{Rm5W}\\
\mathrm{Rm6W}\\
\mathrm{Rm7W}
\end{array}\right) & \mathbf{f}=\left(\begin{array}{ccc}
1 & 15 & 5\\
8 & 22 & 5\\
15 & 16 & 3\\
15 & 8 & 5\\
22 & 1 & 5\\
2 & 16 & 5\\
9 & 10 & 2\\
9 & 23 & 5\\
16 & 9 & 5\\
23 & 22 & 4\\
23 & 2 & 5\\
3 & 2 & 1\\
3 & 17 & 5\\
10 & 11 & 2\\
10 & 24 & 5\\
17 & 21 & 3\\
17 & 10 & 5\\
24 & 3 & 5\\
4 & 3 & 1\\
4 & 18 & 5\\
11 & 12 & 2\\
11 & 25 & 5\\
18 & 11 & 5\\
25 & 4 & 5\\
5 & 4 & 1\\
5 & 19 & 5\\
12 & 26 & 5\\
19 & 12 & 5\\
26 & 27 & 4\\
26 & 5 & 5\\
6 & 20 & 5\\
13 & 27 & 5\\
20 & 19 & 3\\
20 & 13 & 5\\
27 & 6 & 5\\
7 & 21 & 5\\
14 & 28 & 5\\
21 & 14 & 5\\
28 & 24 & 4\\
28 & 7 & 5
\end{array}\right)\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
With some patience, it is even feasible to draw the entire automaton:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 30text%
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Discrete Event Systems/DES_coursework/imgs/MR_automaton.svg
	width 40text%

\end_inset


\begin_inset space \hspace{}
\length 30text%
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Formula $G_{Tot}$
\end_inset

 automaton.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Modeling partial observability 
\end_layout

\begin_layout Standard
As stated in the assessment, the robot is unaware of its heading; however,
 we can assume that its location it is still available.
 For this reason, our initial state is not completely known, as we could
 be in a room with any orientation, and if the next event is a rotation
 one, we'll continue to stay in the same one.
 Only when an event 
\emph on
m
\emph default
 happens, the robot moves in another room, and since the robot can move
 only in the looking-forward direction, from that moment we'll know the
 direction of the robot, and this information will not be lose.
\end_layout

\begin_layout Standard
For this reason, the matlab function that generates the new automaton has
 two main goals:
\end_layout

\begin_layout Enumerate
Substitute every transition in the parallel automaton with the new set of
 events 
\begin_inset Formula $E=\left['m','r'\right]$
\end_inset


\end_layout

\begin_layout Enumerate
Add the new possible initial state for this automaton, as well as every
 transition that might occur.
\end_layout

\begin_layout Standard
The resulting automaton will be non-deterministic due to the uncertainty
 on the initial state.
\end_layout

\begin_layout Standard
Then, both resulting code and the list of events, states, and transitions,
 are presented in the next two pages:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newgeometry{left=1.5cm, right=1.5cm, top=1.5cm, bottom=1.5cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Matlab,numbers=left,stepnumber=5,basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

function G_out = partial_obs(G_in)
\end_layout

\begin_layout Plain Layout

% function that change the automaton following the new partial
\end_layout

\begin_layout Plain Layout

% observability condition.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G_out = struct("E",0, "X",G_in.X, "f",G_in.f, "x0",0);
\end_layout

\begin_layout Plain Layout

new_e = ['m','r']';
\end_layout

\begin_layout Plain Layout

G_out.E = new_e;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% now, we determine the position of events to be substituted
\end_layout

\begin_layout Plain Layout

e2remove = ['n','s','e','w']';
\end_layout

\begin_layout Plain Layout

e_index = zeros(4,1);
\end_layout

\begin_layout Plain Layout

for e=1:length(e2remove)
\end_layout

\begin_layout Plain Layout

    e_index(e) = find( G_in.E == e2remove(e));
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

r_old = find( G_in.E == 'r');
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% change the indexes of events
\end_layout

\begin_layout Plain Layout

for i=1:height(G_in.f)
\end_layout

\begin_layout Plain Layout

    if ( ismember(G_in.f(i,3),e_index) )
\end_layout

\begin_layout Plain Layout

        G_out.f(i,3) = 1;
\end_layout

\begin_layout Plain Layout

    elseif ( ismember(G_in.f(i,3),r_old) )
\end_layout

\begin_layout Plain Layout

        G_out.f(i,3) = 2;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% finally, add the initial states
\end_layout

\begin_layout Plain Layout

room = extractBefore(G_in.x0,4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% build the state for x0
\end_layout

\begin_layout Plain Layout

tmp_state = "{";
\end_layout

\begin_layout Plain Layout

heading = ["N","S","E","W"];
\end_layout

\begin_layout Plain Layout

for i=1:length(heading)
\end_layout

\begin_layout Plain Layout

    tmp_state = tmp_state + room + heading(i) + ",";
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

tmp_state = char(tmp_state);
\end_layout

\begin_layout Plain Layout

tmp_state(end) = '}';
\end_layout

\begin_layout Plain Layout

G_in.x0 = string(tmp_state);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% add all the other possible initial state
\end_layout

\begin_layout Plain Layout

add_state = [tmp_state];
\end_layout

\begin_layout Plain Layout

for i=1:( (length(G_out.X)/length(heading))-1 ) % up to 6 in our case
\end_layout

\begin_layout Plain Layout

    tmp_state = replace(tmp_state, num2str(i), num2str(i+1));
\end_layout

\begin_layout Plain Layout

    add_state = [add_state; tmp_state];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

orig_length = height(G_out.X);
\end_layout

\begin_layout Plain Layout

G_out.X = [G_out.X; add_state];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% add the new possible transitions:
\end_layout

\begin_layout Plain Layout

add_state = string(add_state);
\end_layout

\begin_layout Plain Layout

new_len = height(G_out.X);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% those that are loops through 'r' event
\end_layout

\begin_layout Plain Layout

for x=orig_length+1:new_len
\end_layout

\begin_layout Plain Layout

    G_out.f = [G_out.f; [x x find(G_out.E == 'r')]];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% those that goes to a deterministic state
\end_layout

\begin_layout Plain Layout

trans_f = find (G_out.f(:,3) == 1);
\end_layout

\begin_layout Plain Layout

for i=1:length(trans_f)
\end_layout

\begin_layout Plain Layout

    % find the initial state that contains the one involved in transition
\end_layout

\begin_layout Plain Layout

    offset = find(contains(add_state, G_out.X(G_out.f(trans_f(i),1))));
\end_layout

\begin_layout Plain Layout

	G_out.f = [G_out.f;
\end_layout

\begin_layout Plain Layout

         [orig_length+offset G_out.f(trans_f(i),2) find(G_out.E == 'r')] ];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size scriptsize
\begin_inset Formula 
\[
\begin{array}{ccc}
\mathbf{E}=\left(\begin{array}{c}
m\\
r
\end{array}\right) & \mathbf{X}=\left(\begin{array}{c}
\mathrm{Rm1N}\\
\mathrm{Rm2N}\\
\mathrm{Rm3N}\\
\mathrm{Rm4N}\\
\mathrm{Rm5N}\\
\mathrm{Rm6N}\\
\mathrm{Rm7N}\\
\mathrm{Rm1S}\\
\mathrm{Rm2S}\\
\mathrm{Rm3S}\\
\mathrm{Rm4S}\\
\mathrm{Rm5S}\\
\mathrm{Rm6S}\\
\mathrm{Rm7S}\\
\mathrm{Rm1E}\\
\mathrm{Rm2E}\\
\mathrm{Rm3E}\\
\mathrm{Rm4E}\\
\mathrm{Rm5E}\\
\mathrm{Rm6E}\\
\mathrm{Rm7E}\\
\mathrm{Rm1W}\\
\mathrm{Rm2W}\\
\mathrm{Rm3W}\\
\mathrm{Rm4W}\\
\mathrm{Rm5W}\\
\mathrm{Rm6W}\\
\mathrm{Rm7W}\\
\{Rm1N,Rm1S,Rm1E,Rm1W\}\\
\{Rm2N,Rm2S,Rm2E,Rm2W\}\\
\{Rm3N,Rm3S,Rm3E,Rm3W\}\\
\{Rm4N,Rm4S,Rm4E,Rm4W\}\\
\{Rm5N,Rm5S,Rm5E,Rm5W\}\\
\{Rm6N,Rm6S,Rm6E,Rm6W\}\\
\{Rm7N,Rm7S,Rm7E,Rm7W\}
\end{array}\right) & \mathbf{f}=\left(\begin{array}{ccc}
1 & 15 & 2\\
8 & 22 & 2\\
15 & 16 & 1\\
15 & 8 & 2\\
22 & 1 & 2\\
2 & 16 & 2\\
9 & 10 & 1\\
9 & 23 & 2\\
16 & 9 & 2\\
23 & 22 & 1\\
23 & 2 & 2\\
3 & 2 & 1\\
3 & 17 & 2\\
10 & 11 & 1\\
10 & 24 & 2\\
17 & 21 & 1\\
17 & 10 & 2\\
24 & 3 & 2\\
4 & 3 & 1\\
4 & 18 & 2\\
11 & 12 & 1\\
11 & 25 & 2\\
18 & 11 & 2\\
25 & 4 & 2\\
5 & 4 & 1\\
5 & 19 & 2\\
12 & 26 & 2\\
19 & 12 & 2\\
26 & 27 & 1\\
26 & 5 & 2\\
6 & 20 & 2\\
13 & 27 & 2\\
20 & 19 & 1\\
20 & 13 & 2\\
27 & 6 & 2\\
7 & 21 & 2\\
14 & 28 & 2\\
21 & 14 & 2\\
28 & 24 & 1\\
28 & 7 & 2\\
29 & 29 & 2\\
30 & 30 & 2\\
31 & 31 & 2\\
32 & 32 & 2\\
33 & 33 & 2\\
34 & 34 & 2\\
35 & 35 & 2\\
29 & 16 & 2\\
30 & 10 & 2\\
30 & 22 & 2\\
31 & 2 & 2\\
31 & 11 & 2\\
31 & 21 & 2\\
32 & 3 & 2\\
32 & 12 & 2\\
33 & 4 & 2\\
33 & 27 & 2\\
34 & 19 & 2\\
35 & 24 & 2
\end{array}\right)\end{array}
\]

\end_inset


\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
restoregeometry
\end_layout

\end_inset


\end_layout

\begin_layout Section
Estimating position and heading
\end_layout

\begin_layout Standard
Unlike the previous point, neither position nor heading is available for
 localization.
 For this reason, the entire state space is a possible initial state, and
 following the hint provided by the assignment, we can represent the states
 as row vectors of zeros and ones (hence 
\begin_inset Formula $x_{0}=\begin{bmatrix}1 & 1 & \cdots & 1\end{bmatrix}$
\end_inset

).
 Then, an algorithm is developed in order to compute every reachable state,
 for every enabled event, eliminating all the state that are no more reachable,
 and proceeding in a parallel in-depth search until we end up in single
 states (as we'll see later on).
\end_layout

\begin_layout Standard
Now, answering to all the point asked in the assignment:
\end_layout

\begin_layout Enumerate
There are 77 states for the observer automaton, which can be listed as (notice:
 every state is made by a row:
\size tiny

\begin_inset Formula 
\[
X=\left(\begin{array}{cccccccccccccccccccccccccccc}
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\
0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 & 0\\
0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Enumerate
To provide a better verification tool, the sum of the row and column, as
 well the first 4 singular values are provided:
\begin_inset Formula 
\[
Rows=\left(\begin{array}{c}
28\\
12\\
4\\
12\\
2\\
4\\
4\\
12\\
2\\
2\\
4\\
1\\
4\\
12\\
1\\
2\\
2\\
4\\
4\\
1\\
1\\
4\\
4\\
1\\
2\\
2\\
2\\
4\\
1\\
1\\
1\\
4\\
4\\
2\\
4\\
1\\
2\\
2\\
2\\
2\\
1\\
1\\
1\\
1\\
1\\
4\\
2\\
1\\
2\\
4\\
1\\
1\\
2\\
1\\
1\\
1\\
4\\
2\\
1\\
2\\
4\\
1\\
1\\
1\\
4\\
2\\
1\\
2\\
1\\
1\\
2\\
2\\
1\\
2\\
2\\
2\\
2
\end{array}\right)Cols=\left(\begin{array}{cccccccccccccccccccccccccccc}
5 & 9 & 13 & 10 & 8 & 5 & 7 & 5 & 9 & 13 & 10 & 8 & 5 & 7 & 5 & 9 & 13 & 10 & 8 & 5 & 7 & 5 & 9 & 13 & 10 & 8 & 5 & 7\end{array}\right)Sing\_vals=\left(\begin{array}{c}
8.2219\\
4.7713\\
4.2310\\
4.2310
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newgeometry{left=1.5cm, right=1.5cm, top=1.5cm, bottom=1.5cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\begin_inset listings
lstparams "language=Matlab,numbers=left,stepnumber=10,basicstyle={\scriptsize},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

function G_out = observer(G_in) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G_out = struct("E",0, "X",0, "f",0, "x0",0);
\end_layout

\begin_layout Plain Layout

% we have to first convert the event and transitions lists
\end_layout

\begin_layout Plain Layout

G_in = convert2parobs(G_in); 
\end_layout

\begin_layout Plain Layout

G_out.E = G_in.E;
\end_layout

\begin_layout Plain Layout

% as suggested the whole initial state is given by the vector of all ones
\end_layout

\begin_layout Plain Layout

% notice that the state will be expressed as a row, so that the "vector"
 of
\end_layout

\begin_layout Plain Layout

% states will always be a column vector.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G_out.f = {};
\end_layout

\begin_layout Plain Layout

G_out.x0 = ones(1,height(G_in.X));
\end_layout

\begin_layout Plain Layout

G_out.X = G_out.x0; % the first defined state
\end_layout

\begin_layout Plain Layout

x_new = G_out.x0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while height(x_new) > 0
\end_layout

\begin_layout Plain Layout

	x_til = x_new(1,:); % take the first state,
\end_layout

\begin_layout Plain Layout

    x_new(1,:) = [];   % and remove it from the queue of states
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		for e = 1:length(G_in.E) % compute the reachability
\end_layout

\begin_layout Plain Layout

			state_index = find (G_in.f(:,3) == e);  % find all the states with
\end_layout

\begin_layout Plain Layout

													% the active event 'e'
\end_layout

\begin_layout Plain Layout

			x_next = zeros(1,height(G_in.X));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			for x = 1:length(state_index)
\end_layout

\begin_layout Plain Layout

				x_tmp = G_in.f(state_index(x),1); % starting x state
\end_layout

\begin_layout Plain Layout

				if (x_til(x_tmp) == 1)
\end_layout

\begin_layout Plain Layout

                	% if the Gamma is referred to a state we're considering
\end_layout

\begin_layout Plain Layout

                	x_next(G_in.f(state_index(x),2)) = 1;
\end_layout

\begin_layout Plain Layout

					% then we consider the f(x,e) as a valid transition
\end_layout

\begin_layout Plain Layout

            	end
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

			% once found the new state
\end_layout

\begin_layout Plain Layout

			if any(x_next) % if it is a valid state
\end_layout

\begin_layout Plain Layout

				% we define the transition map
\end_layout

\begin_layout Plain Layout

				G_out.f(end+1,:) = {x_til, x_next, e};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				if ~ismember(x_next, G_out.X,'rows)	 % if the state does not
\end_layout

\begin_layout Plain Layout

														% exist yet
\end_layout

\begin_layout Plain Layout

                G_out.X = [G_out.X; x_next];	% add it to the list
\end_layout

\begin_layout Plain Layout

												% of all states
\end_layout

\begin_layout Plain Layout

                x_new = [x_new; x_next];     % add at the end of the queue
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% implement transitions, based on the order of the new states 
\end_layout

\begin_layout Plain Layout

f_tmp = zeros(height(G_out.f),width(G_out.f));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for h=1:height(G_out.f)
\end_layout

\begin_layout Plain Layout

	f_tmp(h,1) = find (ismember(G_out.X, cell2mat(G_out.f(h,1)),'rows'));
\end_layout

\begin_layout Plain Layout

	f_tmp(h,2) = find (ismember(G_out.X, cell2mat(G_out.f(h,2)),'rows'));
\end_layout

\begin_layout Plain Layout

    f_tmp(h,3) = cell2mat(G_out.f(h,3));
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

G_out.f = f_tmp;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function G_po = convert2parobs(G)
\end_layout

\begin_layout Plain Layout

% In this sub-function, we convert the list of event and transition to the
\end_layout

\begin_layout Plain Layout

% one that we can really observe ('m' and 'r').
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G_po = G;
\end_layout

\begin_layout Plain Layout

new_e = ['m','r']';
\end_layout

\begin_layout Plain Layout

G_po.E = new_e;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% now, we determine the position of events to be substituted
\end_layout

\begin_layout Plain Layout

e2remove = ['n','s','e','w']';
\end_layout

\begin_layout Plain Layout

e_index = zeros(4,1);
\end_layout

\begin_layout Plain Layout

for e=1:length(e2remove)
\end_layout

\begin_layout Plain Layout

	e_index(e) = find( G.E == e2remove(e));
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

r_old = find( G.E == 'r');
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% finally, change the indexes of events
\end_layout

\begin_layout Plain Layout

for i=1:height(G.f)
\end_layout

\begin_layout Plain Layout

	if ( ismember(G.f(i,3),e_index) )
\end_layout

\begin_layout Plain Layout

        G_po.f(i,3) = 1;
\end_layout

\begin_layout Plain Layout

    elseif ( ismember(G.f(i,3),r_old) )
\end_layout

\begin_layout Plain Layout

        G_po.f(i,3) = 2;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
restoregeometry
\end_layout

\end_inset


\end_layout

\begin_layout Section
OLD WORK
\end_layout

\begin_layout Standard
Rewriting the input according to state space representation:
\begin_inset Formula 
\[
u_{f}=\begin{cases}
u_{1}=-\dot{\theta}-(\theta-\theta_{d})\\
u_{2}=-\dot{r}-(r-r_{d})
\end{cases}\rightarrow\begin{cases}
u_{1}=-x_{2}-(x_{1}-\theta_{d})\\
u_{2}=-x_{4}-(x_{3}-r_{d})
\end{cases}\overrightarrow{_{\theta_{d}=0,r_{d}=0}}\begin{cases}
u_{1}=-x_{2}-x_{1}\\
u_{2}=-x_{4}-x_{3}
\end{cases}
\]

\end_inset

Leads the expression 
\begin_inset Formula $\dot{x}=f(x,u_{f})$
\end_inset

 to be: 
\begin_inset Formula 
\[
\dot{x}=\begin{bmatrix}x_{2}\\
\frac{-x_{2}-x_{1}-2x_{3}x_{4}x_{2}}{(x_{3}^{2}+1)}\\
x_{4}\\
-x_{4}-x_{3}+x_{3}x_{2}^{2}
\end{bmatrix}
\]

\end_inset

Again, as suggested by the assignment, we can modify the Lyapunov function
 adding the potential energy (that is expression of 
\begin_inset Formula $\frac{1}{2}\theta^{2}$
\end_inset

 and 
\begin_inset Formula $\frac{1}{2}r^{2}$
\end_inset

, function of position), so that it becomes: 
\begin_inset Formula 
\[
\widetilde{V}(x)=\frac{1}{2}(x_{3}^{2}+1)x_{2}^{2}+\frac{1}{2}x_{4}^{2}+\frac{1}{2}x_{1}^{2}+\frac{1}{2}x_{3}^{2}
\]

\end_inset

Note that in this way, the 
\begin_inset Formula $\widetilde{V}(x)$
\end_inset

 is positive 
\emph on
definite
\emph default
 ( 
\begin_inset Formula $\widetilde{V}(x)=0\Leftrightarrow x=0$
\end_inset

 ), and radially unbounded.
 By calculating the function:
\begin_inset Formula 
\begin{align*}
\dot{\widetilde{V}}(x) & =\frac{\partial V(x)}{\partial x}\cdot f(x)=\begin{bmatrix}x_{1} & x_{2}(x_{3}^{2}+1) & x_{3}(x_{2}^{2}+1) & x_{4}\end{bmatrix}\begin{bmatrix}x_{2}\\
\frac{-x_{2}-x_{1}-2x_{3}x_{4}x_{2}}{(x_{3}^{2}+1)}\\
x_{4}\\
-x_{4}-x_{3}+x_{3}x_{2}^{2}
\end{bmatrix}=\\
 & =x_{1}x_{2}-x_{2}^{2}-x_{1}x_{2}-2x_{3}x_{4}x_{2}^{2}+x_{3}x_{2}^{2}x_{4}+x_{3}x_{4}-x_{4}^{2}-x_{4}x_{3}+x_{4}x_{3}x_{2}^{2}=\\
 & =-x_{2}^{2}-x_{4}^{2}\boldsymbol{\boldsymbol{\leq}}-(\delta_{1}+\epsilon_{2})\begin{bmatrix}x_{2}+x_{1} & x_{4}+x_{3}\end{bmatrix}\begin{bmatrix}x_{2}+x_{1}\\
x_{4}+x_{3}
\end{bmatrix}-(\delta_{2}+\epsilon_{1})\begin{bmatrix}x_{2}\\
x_{4}
\end{bmatrix}\begin{bmatrix}x_{2} & x_{4}\end{bmatrix}\boldsymbol{\leq}0
\end{align*}

\end_inset

At this point we can make some considerations about the feedback system;
 in fact it can be rewritten as a 
\emph on
MIMO linear system
\emph default
, where:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{cccc}
A=\begin{bmatrix}0 & 0\\
0 & 0
\end{bmatrix} & B=\begin{bmatrix}1 & 0\\
0 & 1
\end{bmatrix} & C=\begin{bmatrix}1 & 0\\
0 & 1
\end{bmatrix} & D=\begin{bmatrix}1 & 0\\
0 & 1
\end{bmatrix}\end{array}
\]

\end_inset

however, since the variables are completely decoupled, it can be analyzed
 as two parallel SISO systems (with regard to 
\begin_inset Formula $\theta$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

 respectively), with 
\begin_inset Formula 
\[
A_{1}=0,B_{1}=1,C_{1}=1,D_{1}=1
\]

\end_inset

 as matrices and where each one is 
\emph on
strictly input passive
\emph default
, as their transfer function 
\begin_inset Formula $G(s)=C(sI-A)^{-1}B+D$
\end_inset

 verify the propriety 
\begin_inset Formula $Re\left\{ G(s)\right\} =1\boldsymbol{>}0,\forall s$
\end_inset

.
\end_layout

\begin_layout Standard
For this reason, we can choose as coefficients: 
\begin_inset Formula 
\[
\delta_{1}=\epsilon_{2}=\epsilon_{1}=0,\delta_{2}\in(0,1]
\]

\end_inset

 thus proving that 
\begin_inset Formula $\dot{\widetilde{V}}(x)$
\end_inset

 is semi-definite negative (
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{3}$
\end_inset

 could assume any value).
\begin_inset Newline newline
\end_inset

To prove Global Asymptotic Stability, we can use LaSalle invariance criterion,
 verifying that 
\begin_inset Formula $\left\{ 0\right\} $
\end_inset

 is the largest invariant set contained in 
\begin_inset Formula $Ker\left\{ \dot{\widetilde{V}}\right\} \coloneqq K_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
But 
\begin_inset Formula $Ker\left\{ \dot{\widetilde{V}}\right\} =\left\{ x:-x_{2}^{2}-x_{4}^{2}=0\right\} $
\end_inset

 can be seen as 
\begin_inset Formula 
\[
-\begin{bmatrix}x_{2} & x_{4}\end{bmatrix}\begin{bmatrix}x_{2}\\
x_{4}
\end{bmatrix}=-\left\Vert y_{1}\right\Vert ^{2}=0
\]

\end_inset

and, by the vector norm propriety, 
\begin_inset Formula $\left\Vert y_{1}\right\Vert ^{2}=0\Leftrightarrow y_{1}=0$
\end_inset

.
 For this reason, we can work with a simplified expression 
\begin_inset Formula $K_{0}=\left\{ \begin{bmatrix}x_{2}\\
x_{4}
\end{bmatrix}=\begin{bmatrix}0\\
0
\end{bmatrix}\right\} =\left\{ x_{2}=0\land x_{4}=0\right\} =\mathbb{R}^{2}$
\end_inset

 (
\begin_inset Formula $x_{1}x_{3}$
\end_inset

 plane).
 Using Lie derivatives, it is possible to calculate: 
\begin_inset Formula 
\begin{align*}
K_{1} & =\left\{ x:K_{0}\land\mathcal{L}_{f}^{1}\begin{bmatrix}x_{2}\\
x_{4}
\end{bmatrix}=\frac{\partial\begin{bmatrix}x_{2}\\
x_{4}
\end{bmatrix}}{\partial x}f(x)=0\right\} =\left\{ K_{0}\land\begin{bmatrix}0 & 1 & 0 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}\begin{bmatrix}x_{2}\\
\frac{-x_{2}-x_{1}-2x_{3}x_{4}x_{2}}{(x_{3}^{2}+1)}\\
x_{4}\\
-x_{4}-x_{3}+x_{3}x_{2}^{2}
\end{bmatrix}=0\right\} \\
 & =\left\{ K_{0}\land\begin{bmatrix}\frac{-x_{2}-x_{1}-2x_{3}x_{4}x_{2}}{(x_{3}^{2}+1)}\\
-x_{4}-x_{3}+x_{3}x_{2}^{2}
\end{bmatrix}=0\right\} 
\end{align*}

\end_inset

 and using the relations found in the previous iteration, we could simplify
 the expression:
\begin_inset Formula 
\[
\left\{ K_{0}\land\begin{bmatrix}\frac{-x_{1}}{(x_{3}^{2}+1)}\\
-x_{3}
\end{bmatrix}=0\right\} =\left\{ K_{0}\land\begin{bmatrix}x_{1}\\
x_{3}
\end{bmatrix}=0\right\} =\left\{ x_{2}=0\land x_{4}=0\land x_{1}=0\land x_{3}=0\right\} =\left\{ 0\right\} =K_{1}
\]

\end_inset

So the largest invariant set is 
\begin_inset Formula $\Omega\subset K_{1}=\left\{ 0\right\} \Rightarrow\left\{ 0\right\} $
\end_inset

 is GAS.
\end_layout

\begin_layout Section
Simulate the system for different constant values of 
\begin_inset Formula $r_{d}$
\end_inset

 and 
\begin_inset Formula $\theta_{d}$
\end_inset


\end_layout

\begin_layout Standard
In order to show the results achieved in a way conceptually similar to reality,
 the simulation has been carried out in Simulink.
 The built model is the following one, where:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
the System block is described by the following Matlab function:
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Matlab,tabsize=4"
inline false
status open

\begin_layout Plain Layout

function [xDot,y] = System(x,u)
\end_layout

\begin_layout Plain Layout

	xDot=zeros(4,1); % defining size of xDot 
\end_layout

\begin_layout Plain Layout

					 % (required for simulation)
\end_layout

\begin_layout Plain Layout

	xDot(1) = x(2);
\end_layout

\begin_layout Plain Layout

	xDot(2) = (u(1)-2*x(3)*x(4)*x(2))/((x(3)^2)+1);
\end_layout

\begin_layout Plain Layout

	xDot(3) = x(4);
\end_layout

\begin_layout Plain Layout

	xDot(4) = u(2)+x(3)*(x(2)^2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	y=zeros(2,1); % defining size of y
\end_layout

\begin_layout Plain Layout

	y(1)=x(2); 
\end_layout

\begin_layout Plain Layout

	y(2)=x(4);
\end_layout

\begin_layout Plain Layout

end 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
the IC block allows to set a specific initial condition (in our case, it's
 sufficient to not be the origin, since it is an equilibrium).
\end_layout

\begin_layout Itemize
the feedback loop is built from the output 
\emph on
y
\emph default
 and accordingly to the equation given by the assignment.
\end_layout

\begin_layout Itemize
the scope is attached to the state, showing that all its components converge
 to a specific value.
\end_layout

\begin_layout Standard
Another way to describe the system is through a Matlab function that would
 be integrated through ode45:
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Matlab,tabsize=4"
inline false
status open

\begin_layout Plain Layout

function [xDot] = sys(t,x)
\end_layout

\begin_layout Plain Layout

	global theta_d r_d;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	u(1)=-x(2)-( x(1) - theta_d );
\end_layout

\begin_layout Plain Layout

	u(2)=-x(4)-( x(3) - r_d );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	xDot(1,1) = x(2);
\end_layout

\begin_layout Plain Layout

	xDot(2,1) = (u(1)-2*x(3)*x(4)*x(2))/((x(3)^2)+1);
\end_layout

\begin_layout Plain Layout

	xDot(3,1) = x(4);
\end_layout

\begin_layout Plain Layout

	xDot(4,1) = u(2)+x(3)*(x(2)^2);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

where the global variables are set into an external script to be easily
 accessible and editable.
\end_layout

\begin_layout Standard
he simulations - we refer to the first plot due to its smaller scale and
 better resolution -, once the 
\begin_inset Formula $\theta_{d}$
\end_inset

 and 
\begin_inset Formula $r_{d}$
\end_inset

 value are fixed and the system begins to evolve, as we can see the 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{3}$
\end_inset

 components of the state ( 
\begin_inset Formula $\theta$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

 respectively) converge to the reference values, while 
\begin_inset Formula $x_{2}$
\end_inset

 and 
\begin_inset Formula $x_{4}$
\end_inset

 (that are 
\begin_inset Formula $\dot{\theta}$
\end_inset

 and 
\begin_inset Formula $\dot{r}$
\end_inset

) reduce their amplitude towards zero as the state approaches the asymptotic
 value.
 
\end_layout

\begin_layout Standard
h higher reference value, the overshoot of both the components of the state
 increases, but eventually, after a long transient, the state converges
 to: 
\begin_inset Formula 
\[
x_{\infty}=\begin{bmatrix}\theta_{d} & 0 & r_{d} & 0\end{bmatrix}^{T}
\]

\end_inset

In conclusion, we can claim that the controller achieves 
\emph on
asymptotic tracking
\emph default
 
\emph on
for constant values
\emph default
, with the special case of 
\begin_inset Formula $\theta_{d}=0,r_{d}=0$
\end_inset

, where the converging point is the origin.
\end_layout

\begin_layout Section
Prove that the closed-loop system is not ISS
\end_layout

\begin_layout Subsection
Build an appropriate input signal
\end_layout

\begin_layout Standard
Unfortunately, this point was not really clear for me.
 Due to the hint to use the Lyapunov function and the form of 
\begin_inset Formula $k(x(t)):\mathbb{R}^{4}\longrightarrow\mathbb{R}$
\end_inset

 for the disturbance, I initially thought that the function was exactly
 
\begin_inset Formula $\widetilde{V}(x)$
\end_inset

, or a similar function; however, this cannot be possible, since a sign
 definite function would simple lead to a constant value tracking.
\end_layout

\begin_layout Standard
On the other hand, since the idea is to maximize the power, we could touch
 the variables that are involved with velocity (
\begin_inset Formula $x_{2}$
\end_inset

 or 
\begin_inset Formula $x_{4}$
\end_inset

), and since 
\begin_inset Formula $\theta_{d}$
\end_inset

appears in 
\begin_inset Formula $x_{2}$
\end_inset

, and according to the simulation for constant values, the best approach
 would be to invert the input signal every time the 
\begin_inset Formula $x_{2}$
\end_inset

 crosses zero.
 As we would expect, 
\begin_inset Formula $x_{1}$
\end_inset

 has an oscillatory unbounded solution (it is directly influenced by 
\begin_inset Formula $x_{2}$
\end_inset

, so that each time the solution changes direction, it is accelerated by
 the new value of derivative).
 Moreover, the disturbance should have a rather large constant compared
 to initial condition, being the only positive term for 
\begin_inset Formula $\dot{x_{2}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Another consideration could be done using the derivative of Lyapunov function
 with this specific disturbance.
 In fact, doing some calculations, for 
\begin_inset Formula $\theta_{d}=c\cdot sign\left(k\left(x\left(t\right)\right)\right),r_{d}=0$
\end_inset

, we obtain:
\begin_inset Formula 
\[
\dot{\widetilde{V}}(x,d)=-x_{2}^{2}-x_{4}^{2}+x_{2}\cdot c\cdot sign\left(k\left(x\left(t\right)\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
and choosing 
\begin_inset Formula $k\left(x\left(t\right)\right)=x_{2}$
\end_inset

, we would get:
\begin_inset Formula 
\[
\dot{\widetilde{V}}(x,d)=-x_{2}^{2}-x_{4}^{2}+\left|x_{2}\right|\cdot c
\]

\end_inset


\end_layout

\begin_layout Standard
that not only is not definite negative, it is also not sign defined for
 
\begin_inset Formula $c>0$
\end_inset

.
 Even with some manipulations (rewriting 
\begin_inset Formula $\dot{\widetilde{V}}(x,d)$
\end_inset

 as 
\begin_inset Formula $-\frac{x_{2}^{2}}{2}-x_{4}^{2}+\frac{\theta_{d}^{2}}{2}$
\end_inset

, or find 
\begin_inset Formula $\chi\left(\left|\theta_{d}\right|\right)=2\left|\theta_{d}\right|=2\left|c\cdot sign\left(k\left(x\left(t\right)\right)\right)\right|=2\left|c\right|$
\end_inset

) we cannot use this Lyapunov function as an ISS one of either types; another
 proof is given by Theorem 19 on Lecture Notes.
\end_layout

\begin_layout Subsection
Show the resulting simulation
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t3_r0_x1_orig.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t3_r0_x1_mod.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simulation with 
\begin_inset Formula $\theta_{d}=3sign\left(x_{2}\right),r_{d}=0$
\end_inset

 and 
\begin_inset Formula $x_{0}=\begin{bmatrix}1 & 1 & 1 & 1\end{bmatrix}^{T}$
\end_inset

for both original and modified feedback.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As noticeable by the figure and by their description, we have chosen the
 same exact conditions, while using different feedback, where the second
 one is the same used in the next point analysis.
 In the first one, both 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{3}$
\end_inset

 are diverging and, while 
\begin_inset Formula $x_{2}$
\end_inset

 becomes somewhat the same at each cycle of its waveform, 
\begin_inset Formula $x_{4}$
\end_inset

 continues to increase its peak, pushing higher 
\begin_inset Formula $x_{3}$
\end_inset

 and consequently 
\begin_inset Formula $x_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t100_r0_x1.pdf
	lyxscale 50
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simulation with 
\begin_inset Formula $\theta_{d}=100sign\left(x_{2}\right),r_{d}=0$
\end_inset

 and 
\begin_inset Formula $x_{0}=\begin{bmatrix}1 & 1 & 1 & 1\end{bmatrix}^{T}$
\end_inset

, original feedback.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even for larger times, the state continues to increase, following an 
\begin_inset Formula $\sqrt{x}$
\end_inset

 form and thus being unbounded, while having a bounded input.
\end_layout

\begin_layout Section
Show that the modified feedback fulfills the ISS properties
\end_layout

\begin_layout Standard
With the new pair of inputs:
\begin_inset Formula 
\[
u_{N}=\begin{cases}
u_{1}=-\dot{\theta}-(\theta-\theta_{d})\\
u_{2}=-\dot{r}-(r-r_{d})-(r^{3}-r_{d}^{3})
\end{cases}\rightarrow\begin{cases}
u_{1}=-x_{2}-(x_{1}-\theta_{d})\\
u_{2}=-x_{4}-(x_{3}-r_{d})-(x_{3}^{3}-r_{d}^{3})
\end{cases}
\]

\end_inset

the state space representation becomes:
\begin_inset Formula 
\[
\dot{x}=\begin{bmatrix}x_{2}\\
\frac{-x_{2}-(x_{1}-\theta_{d})-2x_{3}x_{4}x_{2}}{(x_{3}^{2}+1)}\\
x_{4}\\
-x_{4}-(x_{3}-r_{d})-(x_{3}^{3}-r_{d}^{3})+x_{3}x_{2}^{2}
\end{bmatrix}
\]

\end_inset

Then, doing some computations, we can show how this system fulfills the
 typical ISS properties.
\end_layout

\begin_layout Subsubsection
Input-to-State Stable Definition
\end_layout

\begin_layout Standard
A system is ISS if and only if:
\begin_inset Formula 
\[
\left|\phi\left(t,x_{0},d\right)\right|\leq\max\left\{ \beta\left(\left|x_{0}\right|,t\right),\gamma\left(\left\Vert d\right\Vert _{\infty}\right)\right\} ,\beta\in\mathcal{KL},\gamma\in\mathcal{K}_{\infty}
\]

\end_inset

Due to this definition, we have a shape in which our solution is bounded,
 and for large time, it almost solely depends on the second term.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t5_r7_x10.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t5_r7_x15.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simulation for 
\begin_inset Formula $\theta_{d}=5sign\left(x_{2}\right),r_{d}=7$
\end_inset

, and 
\begin_inset Formula $x_{0_{1}}=\begin{bmatrix}10 & 10 & 10 & 10\end{bmatrix}^{T}$
\end_inset

,
\begin_inset Formula $x_{0_{2}}=\begin{bmatrix}15 & 15 & 15 & 15\end{bmatrix}^{T}$
\end_inset

respectively.
\end_layout

\end_inset


\end_layout

\end_inset

As we can notice from the two figures above, when 
\begin_inset Formula $x_{0}$
\end_inset

 increases the transient does the same, while the disturbance, being the
 same, leaves the second part of the bound (given by 
\begin_inset Formula $\gamma$
\end_inset

 for large time) unaltered.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 27.5text%
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t5_r11_x10.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simulation for 
\begin_inset Formula $\theta_{d}=5sign\left(x_{2}\right),r_{d}=11$
\end_inset

, and 
\begin_inset Formula $x_{0}=\begin{bmatrix}10 & 10 & 10 & 10\end{bmatrix}^{T}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

When the disturbance increases (only one component in our example for simplicity
 of analysis), we can note how the 
\begin_inset Formula $\gamma$
\end_inset

 part increases, leading to a steady state value bigger according to 
\begin_inset Formula $\mathcal{K}_{\infty}$
\end_inset

 function definition.
\end_layout

\begin_layout Subsubsection
Converging-Input Converging-State (CICS)
\end_layout

\begin_layout Standard
To prove this property, we could choose a suitable disturbance that goes
 to zero for 
\begin_inset Formula $t\rightarrow+\infty$
\end_inset

.
 For simplicity of analysis 
\begin_inset Formula $r_{d}$
\end_inset

is fixed to zero, while 
\begin_inset Formula $\theta_{d}=3e^{-\frac{t}{10}}$
\end_inset

, an 
\begin_inset Formula $\mathcal{L}$
\end_inset

-type function (again, one of the simplest possible).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 27.5text%
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t3exp_r0_x1.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simulation for 
\begin_inset Formula $\theta_{d}=3e^{-\frac{t}{10}},r_{d}=0$
\end_inset

, and 
\begin_inset Formula $x_{0}=\begin{bmatrix}1 & 1 & 1 & 1\end{bmatrix}^{T}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

As we can notice from the figure, after a transient somewhat 
\begin_inset Quotes eld
\end_inset

chaotic
\begin_inset Quotes erd
\end_inset

, the system is bounded by the 
\begin_inset Formula $\gamma$
\end_inset

 part of the ISS definition, thus the solution goes down exponentially to
 zero.
\end_layout

\begin_layout Subsubsection
0-GAS
\end_layout

\begin_layout Standard
The Global Asymptotic Stability in absence of disturbance (
\begin_inset Formula $d=0$
\end_inset

), means that the solution is bounded by the 
\begin_inset Formula $\beta$
\end_inset

 part of the ISS definition, an 
\begin_inset Formula $\mathcal{L}$
\end_inset

-type function that eventually goes to zero for 
\begin_inset Formula $t\rightarrow+\infty$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t0_r0_x1.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename /media/filippob/2A1C83641C832A41/Users/Filippo Badalamenti/Desktop/Universita'/Imperial College/Stab&Contr of NL Systems/Courseworks/Coursework2/png/evolution_t0_r0_x10.pdf
	lyxscale 45
	width 45text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simulation for 
\begin_inset Formula $\theta_{d}=0,r_{d}=0$
\end_inset

, and 
\begin_inset Formula $x_{0_{1}}=\begin{bmatrix}1 & 1 & 1 & 1\end{bmatrix}^{T}$
\end_inset

,
\begin_inset Formula $x_{0_{2}}=\begin{bmatrix}10 & 10 & 10 & 10\end{bmatrix}^{T}$
\end_inset

respectively.
\end_layout

\end_inset


\end_layout

\end_inset

As we can see by the figures, the system goes to zero regardless of initial
 condition and, after an eventually long transient, it converges to the
 origin.
\end_layout

\end_body
\end_document
